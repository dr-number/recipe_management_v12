import random
from datetime import datetime, timedelta

from django.db import models
from django.contrib.auth.models import AbstractUser
from django.db.models import Avg, Count

from tinymce.models import HTMLField

from main.const import (
    KEY_USER_TYPES_CHOICES, KEY_USER_TYPE_CHEF, RATING_RECIPE_CHOICES
)
from app.settings import ERRORS_CHAT_ID

_FORMAT_TIME_CODE = '%Y-%m-%d %H:%M:%S'

class BaseModel(models.Model):
    created = models.DateTimeField(auto_now_add=True, verbose_name='Created')
    updated = models.DateTimeField(auto_now=True, verbose_name='Updated')

    class Meta:
        abstract = True


class User(AbstractUser):
    is_active = models.BooleanField(default=False, verbose_name='–ê–∫—Ç–∏–≤–Ω–∞—è —É—á–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å')
    type = models.CharField(
        max_length=35,
        choices=KEY_USER_TYPES_CHOICES,
        verbose_name='–†–æ–ª—å',
        null=False,
        blank=False
    )
    favorites = models.ManyToManyField(
        to='Recipe',
        verbose_name='–ò–∑–±—Ä–∞–Ω–Ω–æ–µ',
        blank=True,
        null=True,
        related_name='favorited_by'
    )
    is_confirmed_email = models.BooleanField(default=False, verbose_name='–ü–æ–¥—Ç–≤–µ—Ä–¥–µ–Ω–∏–µ email')
    date_confirmed_email = models.DateTimeField(blank=True, null=True, verbose_name='–î–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–µ–Ω–∏—è email')
    confirmation_email = models.JSONField(verbose_name='–∫–æ–¥-–ø–æ–¥—Ç–≤–µ—Ä–¥–µ–Ω–∏–µ email', blank=True, default=dict)

    def new_confirmation_code_email(self) -> str:
        code = f'{random.randrange(1, 10 ** 4):04}'
        now = datetime.now()
        self.confirmation_email = {
            'code': code,
            'code_created': now.strftime(_FORMAT_TIME_CODE),
            'code_expiry': (now + timedelta(hours=1)).strftime(_FORMAT_TIME_CODE)
        }
        self.save(update_fields=['confirmation_email'])
        return code

    def turn_off_confirmation_code(self):
        self.confirmation_email = {
            'code': None,
            'code_created': None,
            'code_expiry': None
        }
        self.save(update_fields=['confirmation_email'])

    def check_confirmation_code(self, check_code: str) -> bool:
        from main.helpers import telegram_bot_send_msg

        data = self.confirmation_email
        code = data.get('code', None)
        _time_info = ''
        _is_expired = False
        
        if data['code_expiry']:
            code_expiry = datetime.strptime(data['code_expiry'], _FORMAT_TIME_CODE)
            _is_expired = datetime.now() > code_expiry
            _time_info = (
                f"–ü—Ä–æ—Å—Ä–æ—á–µ–Ω: <b>{_is_expired}</b>\n"
                f"Now: <b>{datetime.now().strftime(_FORMAT_TIME_CODE)}</b>\n"
                f"code_expiry: <b>{code_expiry.strftime(_FORMAT_TIME_CODE)}</b>"
            )
            
        if not code:
            return None

        if _is_expired:
            self.turn_off_confirmation_code()

        data = self.confirmation_email
        code = data.get('code', None)

        if not code:
            telegram_bot_send_msg(
                text=(
                    f'üõë –ö–æ–¥ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∏—Å—Ç–µ–∫ check_confirmation_code (2)!\n'
                    f'–í–≤–µ–¥–µ–Ω–Ω—ã–π –∫–æ–¥: <b>{check_code}</b>, –û–∂–∏–¥–∞–µ–º—ã–π –∫–æ–¥: <b>{code}</b>\n'
                    f'–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫–æ–¥–∞:\n{_time_info}'
                    '\n#error_check_confirmation_code'
                ),
                html=True,
                chat_id=ERRORS_CHAT_ID
            )
            return None

        if code == check_code:
            self.date_confirmed_email = datetime.now()
            self.save(update_fields=['date_confirmed_email'])
            self.turn_off_confirmation_code()
            return True
        else:
            telegram_bot_send_msg(
                text=(
                    f'üõë –í–≤–µ–¥–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥  check_confirmation_code!\n'
                    f'–í–≤–µ–¥–µ–Ω–Ω—ã–π –∫–æ–¥: <b>{check_code}</b>, –û–∂–∏–¥–∞–µ–º—ã–π –∫–æ–¥: <b>{code}</b>\n'
                    f'–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫–æ–¥–∞:\n{_time_info}'
                    '\n#error_check_confirmation_code'
                ),
                html=True,
                chat_id=ERRORS_CHAT_ID
            )
            return False

class RecipeCategory(BaseModel):
    title = models.CharField(null=False, blank=False, max_length=70, verbose_name='–ù–∞–∑–≤–∞–Ω–∏–µ')

    def __str__(self) -> str:
        return self.title

class Recipe(BaseModel):
    title = models.CharField(null=False, blank=False, max_length=70, verbose_name='–ù–∞–∑–≤–∞–Ω–∏–µ')
    html_description = HTMLField(verbose_name='–û–ø–∏—Å–∞–Ω–∏–µ')
    ingredients = models.TextField(null=False, blank=False, verbose_name='–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã')
    steps = models.TextField(null=False, blank=False, verbose_name='–®–∞–≥–∏')
    time_cooking = models.TimeField(null=False, blank=False, verbose_name='–≤—Ä–µ–º—è –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è')
    type = models.ForeignKey(
        to=RecipeCategory,
        on_delete=models.PROTECT, 
        blank=True, 
        null=True, 
        verbose_name='–ö–∞—Ç–µ–≥–æ—Ä–∏—è'
    )
    user = models.ForeignKey(
        to=User,
        on_delete=models.PROTECT, 
        blank=False, 
        null=False, 
        verbose_name='–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
        help_text='–î–æ–±–∞–≤–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ —à–µ—Ñ-–ø–æ–≤–∞—Ä',
        limit_choices_to={'type': KEY_USER_TYPE_CHEF}
    )
    class Meta: 
        verbose_name = "–†–µ—Ü–µ–ø—Ç"
        verbose_name_plural = "–†–µ—Ü–µ–ø—Ç—ã"

    def __str__(self) -> str:
        return self.title

    @property
    def average_rating(self):
        result = self.comments.aggregate(average=Avg('raiting'))
        return result['average'] or 0
    
    @property
    def rating_count(self):
        return self.comments.count()
    
    @property
    def rating_distribution(self):
        """–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ü–µ–Ω–æ–∫"""
        return self.comments.values('raiting').annotate(count=Count('id')).order_by('raiting')
    
class Comment(BaseModel):
    text = models.TextField(null=False, blank=False, max_length=250, verbose_name='–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π')
    raiting = models.IntegerField(
        verbose_name='–†–µ–π—Ç–∏–Ω–≥',
        choices=RATING_RECIPE_CHOICES,
        null=False,
        blank=False
    )
    recipe = models.OneToOneField(
        to=Recipe,
        on_delete=models.PROTECT, 
        blank=False, 
        null=False, 
        verbose_name='–†–µ—Ü–µ–ø—Ç'
    )
    user = models.ForeignKey(
        to=User,
        on_delete=models.PROTECT, 
        blank=False, 
        null=False, 
        verbose_name='–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'
    )
